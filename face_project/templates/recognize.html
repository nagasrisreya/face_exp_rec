<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Real-Time Face & Emotion Recognition</title>
  <style>
    /* Page */
    :root{
      --accent:#19a6d6;
      --glass: rgba(255,255,255,0.07);
      --muted: rgba(255,255,255,0.85);
    }
    html,body{height:100%;margin:0;}
    body {
      font-family: "Segoe UI", Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: linear-gradient(135deg,#66c3e6 0%, #8a6bd8 50%, #6dd5ed 100%);
      background-size: 800% 800%;
      animation: gradientBG 18s ease infinite;
      color: #fff;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding: 28px 16px;
    }
    @keyframes gradientBG {
      0%{background-position:0% 50%}
      50%{background-position:100% 50%}
      100%{background-position:0% 50%}
    }

    /* Title */
    header {
      width:100%;
      display:flex;
      justify-content:center;
      align-items:center;
      margin-bottom: 12px;
      pointer-events: none;
    }
    h1 {
      margin: 0;
      font-size: 2.6rem;
      text-align:center;
      text-shadow: 0 6px 12px rgba(0,0,0,0.3);
      letter-spacing: 1px;
      pointer-events: auto;
    }

    /* Video area (no outer bounding card) */
    .video-wrap {
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 12px;
      width: min(88vw, 820px);
    }

    video{
      width: min(84vw, 720px);
      height: auto;
      max-height: 540px;
      border-radius: 14px;
      border: 4px solid rgba(255,255,255,0.95);
      box-shadow: 0 18px 40px rgba(0,0,0,0.35);
      background: #000;
      display:block;
    }

    /* Controls */
    .controls {
      display:flex;
      gap: 12px;
      flex-wrap:wrap;
      justify-content:center;
      align-items:center;
      margin-top: 6px;
    }
    .btn {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:10px 18px;
      border-radius:10px;
      border: none;
      cursor: pointer;
      font-weight:700;
      font-size:15px;
      transition: transform .12s ease, box-shadow .12s ease;
      color:#fff;
    }
    .btn:hover{ transform: translateY(-3px); box-shadow:0 8px 20px rgba(0,0,0,0.25); }
    .btn.start { background: linear-gradient(180deg,#2fb24b,#1c8b32); }
    .btn.stop  { background: linear-gradient(180deg,#ff6b6b,#d82a2a); }
    .btn.manual{ background: linear-gradient(180deg,#3690ff,#0a5fd6); }

    /* response & indicator */
    #response {
      margin-top:10px;
      min-height:24px;
      font-size: 18px;
      color: var(--muted);
      text-shadow: 0 3px 8px rgba(0,0,0,0.25);
    }

    .indicator {
      margin-top:10px;
      padding:6px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,0.08);
      font-weight:700;
      display:inline-block;
      color:#fff;
    }
    .indicator.on {
      background: linear-gradient(90deg, rgba(124,252,0,0.18), rgba(124,252,0,0.08));
      box-shadow: 0 6px 18px rgba(124,252,0,0.08);
    }
    .indicator.off {
      background: rgba(255,255,255,0.06);
      opacity: 0.95;
      box-shadow: none;
    }

    /* Emotion table */
    .table-wrap {
      width: min(88vw, 820px);
      margin-top: 18px;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 12px 30px rgba(0,0,0,0.25);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,0.03);
    }
    table {
      width:100%;
      border-collapse: collapse;
      color: #fff;
    }
    thead th {
      text-align:left;
      font-size:14px;
      padding:12px 16px;
      background: rgba(0,0,0,0.12);
      font-weight:700;
    }
    tbody td {
      padding: 12px 16px;
      font-size:14px;
      border-top: 1px solid rgba(255,255,255,0.03);
    }
    tbody tr:nth-child(even) {
      background: linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    }

    /* Small footer link */
    .bottom {
      margin-top:14px;
    }
    a.home {
      display:inline-block;
      padding:8px 16px;
      background: rgba(0,0,0,0.12);
      color:#fff;
      border-radius:10px;
      text-decoration:none;
      font-weight:700;
    }

    /* Responsive */
    @media (max-width:720px){
      h1{ font-size:1.6rem; margin-top:6px; }
      .btn{ font-size:14px; padding:10px 12px; }
      thead th, tbody td { padding:10px; font-size:13px; }
    }
  </style>
</head>
<body>
  <header><h1>üîç Real-Time Face & Emotion Recognition</h1></header>

  <main class="video-wrap">
    <video id="video" autoplay muted playsinline></video>

    <div class="controls" role="group" aria-label="controls">
      <button class="btn start" id="startBtn">‚ñ∂ Start Counting</button>
      <button class="btn stop" id="stopBtn">‚èπ Stop Counting</button>
      <button class="btn manual" id="manualBtn">üì∏ Manual Recognize</button>
    </div>

    <div id="response">Recognition result will appear here...</div>
    <div id="countingIndicator" class="indicator off">Counting: <strong id="countText">OFF</strong></div>

    <div class="table-wrap" aria-live="polite">
      <table id="emotionTable" role="table">
        <thead>
          <tr>
            <th>Name</th>
            <th>Emotion</th>
            <th>Count</th>
            <th>First Detected</th>
            <th>Last Detected</th>
          </tr>
        </thead>
        <tbody id="emotionBody">
          <tr><td colspan="5" style="color:rgba(255,255,255,0.75);padding:14px 16px">No data yet...</td></tr>
        </tbody>
      </table>
    </div>
  </main>

  <div class="bottom"><a href="/" class="home">‚¨Ö Back to Home</a></div>

  <script>
    // CSRF helper
    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }
    const csrftoken = getCookie('csrftoken');

    // DOM refs
    const video = document.getElementById('video');
    const responseEl = document.getElementById('response');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const manualBtn = document.getElementById('manualBtn');
    const countIndicator = document.getElementById('countingIndicator');
    const countText = document.getElementById('countText');
    const emotionBody = document.getElementById('emotionBody');

    let isProcessing = false;
    let autoInterval = null;

    // Start webcam
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => { video.srcObject = stream; })
      .catch(err => {
        console.error('Camera error:', err);
        responseEl.textContent = 'Camera error: ' + (err.message || err);
      });

    // Capture & send a frame to recognition endpoint
    function captureAndSend() {
      if (isProcessing || video.videoWidth === 0) return;
      isProcessing = true;

      const canvas = document.createElement('canvas');
      canvas.width = 320;
      canvas.height = 240;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      const imageData = canvas.toDataURL('image/jpeg', 0.6);

      fetch('/recognize_user/', {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          'X-CSRFToken': csrftoken,
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: `image=${encodeURIComponent(imageData)}`
      })
      .then(r => r.json())
      .then(data => {
        // Show recognition message (e.g., "Recognized: srey a (Sad)")
        responseEl.textContent = data.message || 'No face recognized.';
        isProcessing = false;
        // refresh table to show new counts (only increments on server if counting is active)
        fetchEmotionStats();
      })
      .catch(err => {
        console.error('Recognition error:', err);
        responseEl.textContent = '‚ö† Error recognizing face.';
        isProcessing = false;
      });
    }

    // Auto recognition runs every 2s (detection independent of counting)
    function startAutoRecognition() {
      if (autoInterval) return;
      autoInterval = setInterval(captureAndSend, 2000);
    }
    function stopAutoRecognition() {
      if (!autoInterval) return;
      clearInterval(autoInterval);
      autoInterval = null;
    }
    // start auto by default so detection continues
    startAutoRecognition();

    // Counting control: call server endpoints to toggle counting flag (server uses this flag to decide whether to increment counts)
    function startCounting() {
      fetch('/start-counting/', {
        method: 'POST',
        credentials: 'same-origin',
        headers: { 'X-CSRFToken': csrftoken }
      })
      .then(r => r.json())
      .then(data => {
        const on = !!data.counting;
        countText.textContent = on ? 'ON' : 'OFF';
        countIndicator.classList.toggle('on', on);
        countIndicator.classList.toggle('off', !on);
        // immediate refresh to see status and counts
        fetchEmotionStats();
      })
      .catch(err => console.error('Start counting error:', err));
    }

    function stopCounting() {
      fetch('/stop-counting/', {
        method: 'POST',
        credentials: 'same-origin',
        headers: { 'X-CSRFToken': csrftoken }
      })
      .then(r => r.json())
      .then(data => {
        const on = !!data.counting;
        countText.textContent = on ? 'ON' : 'OFF';
        countIndicator.classList.toggle('on', on);
        countIndicator.classList.toggle('off', !on);
        fetchEmotionStats();
      })
      .catch(err => console.error('Stop counting error:', err));
    }

    // Fetch server-side counting status and update indicator
    function fetchCountingStatus() {
      fetch('/counting-status/', { credentials: 'same-origin' })
        .then(r => r.json())
        .then(data => {
          const on = !!data.counting;
          countText.textContent = on ? 'ON' : 'OFF';
          countIndicator.classList.toggle('on', on);
          countIndicator.classList.toggle('off', !on);
        })
        .catch(err => console.error('Counting status error:', err));
    }

    // Fetch emotion records and populate table
    function fetchEmotionStats() {
      fetch('/emotion-stats/', { credentials: 'same-origin' })
        .then(r => r.json())
        .then(rows => {
          if (!Array.isArray(rows) || rows.length === 0) {
            emotionBody.innerHTML = '<tr><td colspan="5" style="color:rgba(255,255,255,0.75);padding:14px 16px">No data yet...</td></tr>';
            return;
          }
          emotionBody.innerHTML = rows.map(row => {
            // format datetimes nicely (fallback if missing)
            const firstTime = row.first_detected ? new Date(row.first_detected).toLocaleString() : '-';
            const lastTime  = row.last_detected  ? new Date(row.last_detected).toLocaleString()  : '-';
            return `
              <tr>
                <td>${escapeHtml(row.name)}</td>
                <td>${escapeHtml(row.emotion)}</td>
                <td>${row.count}</td>
                <td>${firstTime}</td>
                <td>${lastTime}</td>
              </tr>
            `;
          }).join('');
        })
        .catch(err => {
          console.error('Error fetching emotion stats:', err);
        });
    }

    // simple helper to avoid injecting raw html for names/emotions
    function escapeHtml(str){
      if (str === null || str === undefined) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Wire buttons
    startBtn.addEventListener('click', startCounting);
    stopBtn.addEventListener('click', stopCounting);
    manualBtn.addEventListener('click', captureAndSend);

    // initial loads
    fetchCountingStatus();
    fetchEmotionStats();

    // periodic refreshes
    setInterval(fetchCountingStatus, 4000); // keep indicator in sync
    setInterval(fetchEmotionStats, 5000);   // update table while app runs
  </script>
</body>
</html>
